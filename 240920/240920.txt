react.js =>todolist // 최적화
1)useMemo
2_react.memo
3.useCallback

컴포넌트의 생애주기?
- 컴포넌트가 브라우저에 최초 출력되는 상황 마운트
- 랜더링 : 컴포넌트 내부에 있는 state 혹은 함수 등의 요소들이 update되는 상황
- 컴포넌트가 관리하고 있는 state값이 복수(2개 이상) 일때에는 state값 1개가 update가 되는 순간 컴포넌트가 다시 랜더링
- 부모컴포넌트 내부에 있는 자식컴포넌트를 사용했다가 종료가 되는 시점

최적화를 하는 이유가 무엇인가?
react.js. 태생적으로 모듈화된 다수의 컴포넌트들을 조합해서 하나의 앱을 완성할 수 밖에 없는 시스템이기 때문에 불필요하게 혹은 비효율적으로 컴포넌트의 리랜더링 혹은 컴포넌트 내부의 함수들의 불필요한 호출들이 빈번하게 발생할 수 밖에 없는 숙명?

- 소소한 작은 규모의 프로젝트 앱의 경우는 사실 최적화가 그렇게 크게 필요하지않다
- 프로젝트의 규모가 커지는 경우 => 외부 api 데이터를 빈번하게 혹은 복수로 가져와서 사용하는 경우, 트래픽 발생이 점점 높아지는 경우, 내부컨텐츠의 용량이 고사양인 경우

최적화를 해야하는 타이밍 // 상황은 언제인가?
- 컴포넌트가 언제 리랜더링이 발생하는가를 고민
- 크게 3가지 밖에 없음
1) 컴포넌트 안에 있는 state값이 update가 되는 상황
2) 부모컴포넌트가 자식컴포넌트에게 전달하는 props의 값이 변경(수정)되거나 추가되는 상황
3) 부모컴포넌트에서 랜더링이 발생되면, 자식컴포넌트에서도 랜더링이 발생

*그렇다면, 최적화를 실행시키는 3가지의 대표적인 방법
1) useMemo : 컴포넌트 내부에 있는 함수의 비효율적인 호출을 방지하고자 할 때
-react.js hooks 함수 중 하나
- 함수는 인자값을 받아서 => 콜백 제어
- useMemo(callback, 의존성배열) => 의존성배열 안에 담긴 값이 업데이트 (변화)가 될 때만 콜백함수를 실행시켜주는 역할

2) react.memo : 부모컴포넌트의 랜더링으로 인한 자식 컴포넌트의 불필요한 리랜더링을 방지하고자 할 때
- 인자값은 반드시 컴포넌트만 받을 수 있음
- 컴포넌트를 제어 => 원래는 부모컴포넌트가 랜더링됨으로 인해서 자식컴포넌트가 운명적으로 리랜더링이 되어야하나, 이 운명을 거슬러서 리랜더링이 안되도록 강화시킴
- 업그레이드가 된 자식컴포넌트를 "고차컴포넌트"화 되었다 = hoc = higher order component
- 프로그래밍 영역에서 프로그램 앱을 개발 => 공통컴포넌트 // 메인컴포넌트 다르게 분류
- 메인기능역할 담당하는 메인컴포넌트 세로(종단)로 배치 // 여기저기에서 공통으로 사용하는 공통컴포넌트 가로(횡단)로 배치

- 횡단 관심사의 요소 = 공통컴포넌트
- react 라이브러리 => React 객체를 찾아와서 컴포넌트 하단 export 영역에서 컴포넌트 네임을 인자값으로 설정
- React.memo(Header)

3) react.memo를 활용해서 부모컴포넌트의 랜더링 여부와 관계없이 자식컴포넌트의 리랜더링을 제어 =>
부모컴포넌트로부터 전달받는 props 2개가 존재 부모에게 전달받지 않는 props가 1개가 존재
- useCallback => 의존성배열을 정의해놓고, 해당 의존성배열안에 담긴 state값이 변할 때에만 내부에 있는 코백함수를 실행시킬 수 있음
useCallback(callback, 의존성배열) => 의존성배열의 변경여부에 따라서 callback 실행여부 판단
=> useCallback: 함수형 업데이트
=> 의존성배열이 존재하지 않는 경우에는 실제함수가 실행될 때에만 랜더링 시킴
=> 딜레마 : 불 필요한 리랜더링을 방지하고자 usecallback을 사용하고, 의존성 배열을 빈배열로 설정하는 경우
state의 최선값을 받아오지 못하는 에러도 발생할 수 있음
함수형 업데이트 형태로 state의 최신값을 항상 받아올 수 있도록 해야함